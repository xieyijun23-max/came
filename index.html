<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Camera Rock Paper Scissors - Always Win</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --cam-aspect: 4 / 3;
      --primary: #2563eb;
      --primary-hover: #1d4ed8;
      --ok: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
      background: radial-gradient(circle at 20% 20%, #1f2937, var(--bg));
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .app {
      width: min(960px, 100%);
      display: grid;
      gap: 16px;
      grid-template-columns: 1.1fr 0.9fr;
    }

    .card {
      background: rgba(17, 24, 39, 0.95);
      border: 1px solid #243041;
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
    }

    .video-wrap {
      position: relative;
      aspect-ratio: var(--cam-aspect);
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid #1f2937;
    }

    .video-wrap.win-flash::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at center, rgba(34, 197, 94, 0.35), rgba(34, 197, 94, 0) 65%);
      animation: flashOut 380ms ease-out forwards;
    }

    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }

    h1 {
      margin: 0 0 10px;
      font-size: 22px;
    }

    .sub {
      margin: 0 0 12px;
      color: var(--muted);
      font-size: 14px;
    }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }

    button {
      border: 0;
      border-radius: 10px;
      padding: 10px 14px;
      font-size: 14px;
      cursor: pointer;
      color: white;
      background: var(--primary);
      transition: 0.15s ease;
    }

    button#startBtn {
      animation: glowPulse 1.9s ease-in-out infinite;
    }

    button:hover {
      background: var(--primary-hover);
    }

    button.secondary {
      background: #374151;
    }

    button.secondary:hover {
      background: #4b5563;
    }

    .line {
      margin: 10px 0;
      padding: 10px;
      border-radius: 10px;
      background: #0b1220;
      border: 1px solid #243041;
    }

    .line .k {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 4px;
    }

    .line .v {
      font-size: 18px;
      font-weight: 700;
    }

    .result.win { color: var(--ok); }
    .result.wait { color: var(--warn); }
    .result.err { color: var(--danger); }

    .score {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-top: 10px;
    }

    .score-item {
      background: #0b1220;
      border: 1px solid #243041;
      border-radius: 10px;
      padding: 10px;
      text-align: center;
    }

    .score-item .label {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 6px;
    }

    .score-item .value {
      font-size: 24px;
      font-weight: 800;
    }

    .score-item .value.bump {
      animation: scoreBump 280ms ease-out;
    }

    .tips {
      margin-top: 12px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.6;
    }

    .confetti-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 999;
    }

    .confetti {
      position: absolute;
      width: 9px;
      height: 15px;
      border-radius: 2px;
      opacity: 0.95;
      animation: confettiFall 950ms linear forwards;
    }

    @keyframes flashOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    @keyframes scoreBump {
      0% { transform: scale(1); }
      35% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    @keyframes glowPulse {
      0%, 100% { box-shadow: 0 0 0 rgba(37, 99, 235, 0); }
      50% { box-shadow: 0 0 22px rgba(37, 99, 235, 0.45); }
    }

    @keyframes confettiFall {
      0% {
        transform: translate3d(0, 0, 0) rotate(0deg);
        opacity: 0.95;
      }
      100% {
        transform: translate3d(var(--dx), var(--dy), 0) rotate(var(--rot));
        opacity: 0;
      }
    }

    @media (max-width: 860px) {
      .app {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <section class="card">
      <h1>Camera Rock Paper Scissors (Always Win)</h1>
      <p class="sub">Show Rock / Scissors / Paper to the camera. Once detected, the bot will always pick the losing move.</p>
      <div id="videoWrap" class="video-wrap">
        <video id="video" playsinline></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="buttons">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" class="secondary">Stop</button>
        <button id="resetBtn" class="secondary">Reset Score</button>
      </div>
    </section>

    <section class="card">
      <div class="line">
        <div class="k">Your Move</div>
        <div id="userMove" class="v">Not Detected</div>
      </div>
      <div class="line">
        <div class="k">Bot Move</div>
        <div id="botMove" class="v">Waiting</div>
      </div>
      <div class="line">
        <div class="k">Round Result</div>
        <div id="resultText" class="v result wait">Please start the camera first</div>
      </div>

      <div class="score">
        <div class="score-item">
          <div class="label">Wins</div>
          <div id="winScore" class="value">0</div>
        </div>
        <div class="score-item">
          <div class="label">Total Rounds</div>
          <div id="roundScore" class="value">0</div>
        </div>
      </div>

      <div class="tips">
        Tips:<br>
        1) Allow camera permission when prompted.<br>
        2) Keep your hand near the center with good lighting.<br>
        3) If recognition is unstable, try a clear Paper/Scissors pose.
      </div>
    </section>
  </div>
  <div id="confettiLayer" class="confetti-layer"></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script>
    const videoEl = document.getElementById("video");
    const videoWrapEl = document.getElementById("videoWrap");
    const canvasEl = document.getElementById("overlay");
    const canvasCtx = canvasEl.getContext("2d");
    const confettiLayerEl = document.getElementById("confettiLayer");
    const userMoveEl = document.getElementById("userMove");
    const botMoveEl = document.getElementById("botMove");
    const resultTextEl = document.getElementById("resultText");
    const winScoreEl = document.getElementById("winScore");
    const roundScoreEl = document.getElementById("roundScore");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const resetBtn = document.getElementById("resetBtn");

    let camera = null;
    let hands = null;
    let roundCount = 0;
    let winCount = 0;
    let lastRoundAt = 0;
    const ROUND_COOLDOWN = 900;
    const history = [];
    const HISTORY_LIMIT = 7;

    const moveMap = {
      rock: "Rock",
      paper: "Paper",
      scissors: "Scissors",
      unknown: "Not Detected"
    };

    function losesTo(userMove) {
      if (userMove === "rock") return "scissors";
      if (userMove === "paper") return "rock";
      if (userMove === "scissors") return "paper";
      return "unknown";
    }

    function setResult(text, type) {
      resultTextEl.textContent = text;
      resultTextEl.className = "v result " + type;
    }

    function updateScore() {
      winScoreEl.textContent = String(winCount);
      roundScoreEl.textContent = String(roundCount);
    }

    function triggerWinFx() {
      videoWrapEl.classList.remove("win-flash");
      // Force reflow so the flash animation can replay on every win.
      void videoWrapEl.offsetWidth;
      videoWrapEl.classList.add("win-flash");

      winScoreEl.classList.remove("bump");
      roundScoreEl.classList.remove("bump");
      void winScoreEl.offsetWidth;
      winScoreEl.classList.add("bump");
      roundScoreEl.classList.add("bump");

      const colors = ["#22c55e", "#38bdf8", "#f59e0b", "#a78bfa", "#f43f5e", "#facc15"];
      const count = 26;
      for (let i = 0; i < count; i += 1) {
        const piece = document.createElement("span");
        piece.className = "confetti";
        piece.style.left = (25 + Math.random() * 50) + "vw";
        piece.style.top = (18 + Math.random() * 18) + "vh";
        piece.style.background = colors[(Math.random() * colors.length) | 0];
        piece.style.setProperty("--dx", (Math.random() * 260 - 130) + "px");
        piece.style.setProperty("--dy", (240 + Math.random() * 340) + "px");
        piece.style.setProperty("--rot", (Math.random() * 720 - 360) + "deg");
        confettiLayerEl.appendChild(piece);
        setTimeout(() => piece.remove(), 980);
      }
    }

    function stableGesture(gesture) {
      history.push(gesture);
      if (history.length > HISTORY_LIMIT) history.shift();
      const counts = { rock: 0, paper: 0, scissors: 0 };
      for (const g of history) {
        if (counts[g] !== undefined) counts[g] += 1;
      }
      let best = "unknown";
      let n = 0;
      for (const k of ["rock", "paper", "scissors"]) {
        if (counts[k] > n) {
          best = k;
          n = counts[k];
        }
      }
      return n >= 4 ? best : "unknown";
    }

    function detectGesture(landmarks) {
      if (!landmarks || landmarks.length !== 21) return "unknown";

      const tip = { thumb: 4, index: 8, middle: 12, ring: 16, pinky: 20 };
      const pip = { index: 6, middle: 10, ring: 14, pinky: 18 };

      const indexUp = landmarks[tip.index].y < landmarks[pip.index].y;
      const middleUp = landmarks[tip.middle].y < landmarks[pip.middle].y;
      const ringUp = landmarks[tip.ring].y < landmarks[pip.ring].y;
      const pinkyUp = landmarks[tip.pinky].y < landmarks[pip.pinky].y;

      // Simplified thumb check: if thumb tip is farther from palm center (point 9), consider it extended.
      const thumbDist = Math.hypot(
        landmarks[tip.thumb].x - landmarks[9].x,
        landmarks[tip.thumb].y - landmarks[9].y
      );
      const thumbBaseDist = Math.hypot(
        landmarks[3].x - landmarks[9].x,
        landmarks[3].y - landmarks[9].y
      );
      const thumbUp = thumbDist > thumbBaseDist * 1.15;

      const upCount = [thumbUp, indexUp, middleUp, ringUp, pinkyUp].filter(Boolean).length;

      if (indexUp && middleUp && !ringUp && !pinkyUp) return "scissors";
      if (upCount >= 4) return "paper";
      if (upCount <= 1) return "rock";
      return "unknown";
    }

    function playRound(userMove) {
      const now = Date.now();
      if (now - lastRoundAt < ROUND_COOLDOWN) return;
      lastRoundAt = now;

      const botMove = losesTo(userMove);
      userMoveEl.textContent = moveMap[userMove];
      botMoveEl.textContent = moveMap[botMove];

      // "Always win" mode: the player is always marked as winner.
      roundCount += 1;
      winCount += 1;
      updateScore();
      triggerWinFx();
      setResult("You win!", "win");
    }

    function onResults(results) {
      const frameWidth = results.image?.width || videoEl.videoWidth || 640;
      const frameHeight = results.image?.height || videoEl.videoHeight || 480;
      if (frameWidth > 0 && frameHeight > 0) {
        document.documentElement.style.setProperty("--cam-aspect", frameWidth + " / " + frameHeight);
      }

      if (canvasEl.width !== frameWidth || canvasEl.height !== frameHeight) {
        canvasEl.width = frameWidth;
        canvasEl.height = frameHeight;
      }

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasEl.width, canvasEl.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasEl.width, canvasEl.height);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
        const lm = results.multiHandLandmarks[0];
        drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, { color: "#22d3ee", lineWidth: 3 });
        drawLandmarks(canvasCtx, lm, { color: "#f59e0b", lineWidth: 1, radius: 4 });

        const raw = detectGesture(lm);
        const gesture = stableGesture(raw);
        userMoveEl.textContent = moveMap[gesture] || moveMap.unknown;

        if (gesture !== "unknown") {
          playRound(gesture);
        } else {
          botMoveEl.textContent = "Waiting";
          setResult("Detecting... keep your hand stable", "wait");
        }
      } else {
        history.length = 0;
        userMoveEl.textContent = "No hand detected";
        botMoveEl.textContent = "Waiting";
        setResult("Please place your hand in view", "wait");
      }
      canvasCtx.restore();
    }

    async function startGame() {
      try {
        if (!hands) {
          hands = new Hands({
            locateFile: (file) => "https://cdn.jsdelivr.net/npm/@mediapipe/hands/" + file
          });
          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.6
          });
          hands.onResults(onResults);
        }

        if (!camera) {
          camera = new Camera(videoEl, {
            onFrame: async () => {
              if (hands) {
                await hands.send({ image: videoEl });
              }
            },
            width: 1280,
            height: 720
          });
        }

        await camera.start();
        setResult("Detection started. Show your move!", "wait");
      } catch (err) {
        setResult("Failed to start camera: check permissions or browser", "err");
        console.error(err);
      }
    }

    function stopGame() {
      try {
        if (videoEl.srcObject) {
          const tracks = videoEl.srcObject.getTracks();
          tracks.forEach((t) => t.stop());
          videoEl.srcObject = null;
        }
      } catch (err) {
        console.error(err);
      }
      setResult("Stopped", "wait");
    }

    function resetScore() {
      roundCount = 0;
      winCount = 0;
      lastRoundAt = 0;
      history.length = 0;
      updateScore();
      userMoveEl.textContent = "Not Detected";
      botMoveEl.textContent = "Waiting";
      setResult("Score reset", "wait");
    }

    startBtn.addEventListener("click", startGame);
    stopBtn.addEventListener("click", stopGame);
    resetBtn.addEventListener("click", resetScore);
  </script>
</body>
</html>
